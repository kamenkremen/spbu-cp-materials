#import "./lib.typ": *
#import "@preview/cetz:0.4.2"
#import "@preview/cetz-plot:0.1.2"

#show: setup_presentation.with(
  height: 12cm,
  authors_short: ("Плотников", "Закарлюка"),
  authors_long: ("Плотников Даннил Михайлович", "Закарлюка Иван Владимирович"),
  title_long: "Вводная лекция",
  title_short: "Вводная лекция",
  institute_long: "Санкт-Петербургский государственный университет",
  institute_short: "СПБГУ",
  date: "Октябрь 2025",
)

#align(center, text(size: 20pt, [*Организационные вопросы*]))
#align(left, text(size: 20pt, [- Лекция во вторник пятой парой
- Контест в субботу 17:30 --- 20:00
- Посещение свободное, в контесте можно участвовать из дома, но круче приходить на факультет 
- Язык программирования --- в целом любой, однако традиционно C++(и на то есть причины!)
- Все материалы лекций будут доступны в репозитории https://github.com/kamenkremen/spbu-cp-materials
- Читаем мы по методичке, ссылка в репозитории и телеге
]))


= Полезные материалы

== Теория
#text(size:20pt, [*e-maxx* (http://e-maxx.ru/algo/)])
#text(size: 14pt)[
    - Большое количество алгоритмов
    - Подробные объяснения с примерами, кодом, задачами(на других платформах)
    - Проверен временем
    - Иногда лежит \u{1F633}
  ]

#text(size:20pt, [*Алгоритмика* (https://algorithmica.org/ru/)])
#text(size: 14pt)[
    - Много алгоритмов и полезных статей, но все равно много чего нет
    - Подробные объяснения с примерами, кодом    
    - Относительно свежий, поэтому написан более понятным языком и с нормально выглядящим сайтом
  ]

==
#text(size:20pt, [*ИТМО вики* (neerc.ifmo.ru/wiki/)])
#text(size: 14pt)[
    - Большое количество не только алгоритмов, но в целом конспектов по математике, компьютер саенсу    
    - Некоторые статьи написаны не очень понятно
    - Некоторые статье написаны не очень правильно
    - Некоторые статьи недописаны
  ]

== Задачи

#text(size:20pt, [*CSES* (https://cses.fi/problemset/)])
#text(size: 14pt)[
    - Много базовых, хороших задач
    - Задачи собраны по темам
  ]

#text(size:20pt, [*Timus* (https://acm.timus.ru/)])
#text(size: 14pt)[
    - Огромное количество хороших задач
    - Сайт прямиком из 2000 года \u{1F644}
  ]



== Универсальные солдаты
#text(size:20pt, [*Leetcode* (https://leetcode.com/)])
#text(size: 14pt)[
    - Большой архив задач
    - Регулярные контесты
    - Больше для подготовки к собесам
  ]

#text(size:20pt, [*acmp* (https://acmp.ru/)])
#text(size: 14pt)[
    - 1000 изначальных задач и ещё куча с разных соревнований
    - Есть несколько курсов с теорией и задачами
    - Устарел не только дизайн, но и теория местами
  ]

==

#text(size:20pt, [*Codeforces* (https://codeforces.com/)])
#text(size: 14pt)[
    - Огромный, все время пополняющийся архив задач
    - Регулярные рейтинговые контесты различной сложности
    - Вполне живое сообщество
    - Хороший курс по некоторым темам, сейчас вроде делается второй
    - Группа кружка в которой будут проходить субботние контесты именно здесь(https://codeforces.com/group/RZ7bF4GcQY/)
  ]

== Достойные упоминания
#text(size: 20pt, [
 - AtCoder (https://atcoder.jp/); 
 - TopCoder (https://www.topcoder.com/);
 - Usaco (https://usaco.org/);
 - SortMe (https://sort-me.org/).
])

= Теория
== Анализ сложности
#text(size: 14pt)[
- Для анализа алгоритмов нужно научиться их сравнивать
- Самые очевидные критерии --- "скорость" выполнения и используемая память. Сейчас поговорим про скорость
- Конечно, можно просто запустить алгоритм. Но тогда
  - На разных компьютерах время работы будет отличаться
  - Не всегда заранее доступны именно те данные, на которых он в реальности будет запускаться.
  - Иногда приходится оценивать алгоритмы, которые будут работать очень долго
  - Хотелось бы уметь оценить алгоритм, до того как садиться его реализовывать. Иначе как вообще придумывать новые нетривиальные алгоритмы?
]

== 
#text(size: 14pt)[
- Попробуем как-нибудь приблизиться к нашим целям. Например, давайте считать количество операций которое совершает алгоритм
- Причем нужно считать количество операций в зависимости от входных данных, ведь иначе алгоритм который принимает $n$ целых чисел и обрабатывает их суммарно за $10$ операций мы можем посчитать хуже алгоритма, который обрабатывает их за $n$ операций(ведь при $n < 10$ это правда будет так!)
- Для этого мы возьмем уже существующую вещь из математики. Она называется О-нотация
]

== О-нотация
  #text(size: 14pt)[

  $g(x) = O(f(x)) => exists C > 0 = "const" : exists x_1: forall x >= x_1 => g(x) <= C f(x)$

  $f(x) = O(sqrt(x))$
]

#cetz.canvas({
    import cetz.draw: *
    import cetz-plot: *

    let green = rgb("#228b22")

    plot.plot(
      size: (15,5),
      x-tick-step: none,
      y-tick-step: none,
      axis-style: "school-book",
      
      {
        plot.add(
          domain: (0,10),
          samples: 500,
          label: [$sqrt(x)$],
          x => calc.pow(x, 0.5),
        )

        plot.add(
          style: (stroke: (paint: green)),
          label: [$f(x)$],
          ((0,0), (2,2), (3,1), (4,2), (7,2.5), (10,2.7))
        )
      }
    )
})

==

#text(size: 14pt)[
  Следствия из определения:
  - $O(C f(x)) = O(f(x))$, например: $O(15x^2) = O(x^2)$
  - $O(f(x) + С) = O(f(x))$, например: $O(x^2 + 15) = O(x^2)$
   - При решении задач нужно не забывать о существовании этих констант. Если она будет сильно большой, то алгоритм может не проходить по времени, хотя асимптотически должно выглядит верным
  - $g(x) = O(f(x)) => O(g(x) + f(x)) = O(f(x))$, например: $x = O(x^2) => $ #linebreak() $=> O(x^2 + x) = O(x^2)$
]

== Небольшое упражнение

#align(center,
  text(size: 14pt)[
    #table(
      stroke: none,
      columns: (auto, auto),
      align: (left, left),
      column-gutter: (2em),
      $f_1(n) = 2n$,                $f_1(n) = O(?)$,
      $f_2(n) = n^2 + 3n$,          $f_2(n) = O(?)$,
      $f_3(n) = n/10^100$,          $f_3(n) = O(?)$,
      $f_4(n) = Sigma_(k=1)^(n)(Sigma_(i=1)^k i)$,   $f_4(n) = O(?)$,
      $f_5(n) = n/3$,               $f_5(n) = O(?)$,
      $f_6(n) = log_2n + 30$,       $f_6(n) = O(?)$,
      $f_7(n) = n^3 + 2^n - 100$,   $f_7(n) = O(?)$,
      $f_8(n) = 10^(10^(10^(10)))$, $f_8(n) = O(?)$,
    )
  ]
)

== Ответы
#align(center,
  text(size: 14pt)[
    #table(
      stroke: none,
      columns: (auto, auto),
      align: (left, left),
      column-gutter: (2em),
      $f_1(n) = 2n$,                $f_1(n) = O(n)$,
      $f_2(n) = n^2 + 3n$,          $f_2(n) = O(n^2)$,
      $f_3(n) = n/10^100$,          $f_3(n) = O(n)$,
      $f_4(n) = Sigma_(k=1)^(n)(Sigma_(i=1)^k i)$,   $f_4(n) = O(n^2)$,
      $f_5(n) = n/3$,               $f_5(n) = O(n)$,
      $f_6(n) = log_2n + 30$,       $f_6(n) = O(log_2 n)$,
      $f_7(n) = n^3 + 2^n - 100$,   $f_7(n) = O(2^n)$,
      $f_8(n) = 10^(10^(10^(10)))$, $f_8(n) = O(1)$,
    )
  ]
)

== Связь с алгоритмами
#text(size: 14pt)[
#align(center)[ 
  Самые часто встречающиеся асимптотики:
  #table(
    columns: (auto, auto, auto), 
    text[Асимптотика], text[Возможный вход], text[Пример алгоритма],
    $O(1)$,       text[Любой], text[Формула],
    $O(log n)$,   text[Огромный], text[Двоичный поиск],
    $O(n)$,       $<=10^8$, text()[Поиск максимума],
    $O(n log n)$, $<=10^6$, text()[Сортировка],
    $O(n^2)$,     $<=10^4$, text()[Перебор пар],
    $O(n^3)$,     $<=10^3$, text()[Алгоритм Флойда-Уоршелла],
    $O(2^n)$,     $<=30$, text[Перебор подмножеств],
    $O(n!)$,      $<=10$, text[Перебор перестановок],
    $O(n^n)$,     text[Никакой], text[Прям полный перебор],
  )]
]

== Упражнение побольше
#text(size: 14pt)[
Какова асимтотика этого алгоритма?
```c 
for j in 1..n-1
  for i in 0..n-1-j
    if a[i] > a[i+1]:
      swap(a[i], a[i + 1])
```
]

== 
#text(size: 14pt)[
Какова асимтотика этого алгоритма?
```c 
for j in 1..n-1
  for i in 0..n-1-j
    if a[i] > a[i+1]:
      swap(a[i], a[i + 1])
```
]

#text(size: 20pt)[
 $O(n^2)$
]

== Ваще огромное упражнение

#text(size: 14pt)[
Какова асимптотика этого алгоритма?
```c
for i = 0 to k
    C[i] = 0;
for i = 0 to n - 1
    C[A[i]] = C[A[i]] + 1;
b = 0;
for j = 0 to k + 1
    for i = 0 to C[j]
        A[b] = j;
        b = b + 1;
```
]

== 

#text(size: 14pt)[
Какова асимптотика этого алгоритма?
```c
for i = 0 to k
    C[i] = 0;
for i = 0 to n - 1
    C[A[i]] = C[A[i]] + 1;
b = 0;
for j = 0 to k + 1
    for i = 0 to C[j]
        A[b] = j;
        b = b + 1;
```
]

#text(size: 20pt)[
 $O(k + n + k n) = O(k n)$
]


== Мастер-теорема
#text(size: 14pt)[
Когда дело доходит до рекурсии, может быть проблематично посчитать время работы алгоритма. Для этого есть мастер-теорема для задачи размера $n$, которая разделяется на $a$ задач в $b$ раз меньшего размера с их объединением за $Theta(n^c)$

Пусть $T(n) = vec(a T(n/b) + Theta(n^c) "при" n>n_0, Theta(1) "при" n <= n_0, delim: "{") $

Тогда
- Если $c > log_b a$, то $T(n) = Theta(n^c)$
- Если $c = log_b a, "то" T(n) = Theta(n^c log n)$
- Если $c < log_b$, то $T(n) = Theta(n^(log_b a))$
]
== Побитовые операции
#text(size: 14pt)[
Любое число(и не только) на самом деле хранится в виде нулей и единиц, то есть в двоичной системе счисления. Поскольку можно трактовать 0 как false а 1 как true, то к ним применимы логические операции(которые применяются к каждому биту, поэтому называются побитовые). Самые часто встречающиеся:
- И(&)
- Или(|)
- Не(\~)
- Исключающее или(^), чаще xor

Так же такое представление позволяет, например, пользоваться сдвигами
- << --- побитовый сдвиг влево
- >> --- побитовый сдвиг вправо
]

== Применения побитовых операций

#text(size: 14pt)[
- << --- По сути, эквивалентен умножению на два
- >> --- По сути, эквивалентен делению на два без остатка
- x & 1 - эквивалентно x % 2
- x & -x --- взятие последнего ненулевой бита числа
- v && !(v & (v - 1)) --- проверка является ли число степенью 2
- \_\_builtin_clz(x) --- посчитать количество ведущих нулей \
- \_\_builtin_ctz(x) --- посчитать количество конечных нулей \
- \_\_builtin_popcount(x) --- посчитать количество единиц в двоичной записи числа \
]


= Алгоритмы
== Сканирующая прямая
#text(size: 14pt)[
#emph(text(red)[
Дан набор из $n$ отрезков на числовой прямой. Нужно найти какую-нибудь точку, которая покрыта наибольшим количеством отрезков])

Как вариант, можно перебирать все точки и считать перебором для каждой, сколько отрезков её покрывает
  - Однако какова будет асимптотика такого решения?
  - Можно попробовать улучшить этот вариант, например, не считать сколько отрезков покрывают точку в лоб
    - Давайте запомним в каких точках сколько отрезков начинаются и кончаются
    - Можем во время прохода по прямой поддерживать сколько сейчас отрезков покрывают точку
  - А если рассматривать только точки в которых отрезок кончается/начинается?
]

== Задача
#emph(text(size:20pt)[
Дан набор из $n$ отрезков на числовой прямой. Дано $q$ точек. Нужно для каждой точки вывести количество отрезков, которому она принадлежит])

== Метод двух указателей
#text(size: 14pt)[
Метод, а не алгоритм, поскольку намного менее конкретный
]

#emph(text(red, size:16pt)[Дан массив чисел $a$, число $k$. Нужно найти максимальный по длине отрезок, такой, что сумма элементов на нем равна $k$])
#text(size: 12pt)[
- Начнем искать с $l = 0$, $r = 0$
- Увеличиваем $r$ пока сумма $<= n$
- Если сумма равна $n$, то возможно ответ найден
- Пока сумма $> n$, увеличиваем $l$
К схожей задаче можно применить метод двух указателей
- если отрезок $[l,r]$ хороший, то любой вложенный в него отрезок также хороший
- или если  отрезок $[l,r]$ хороший, то любой отрезок, который его содержит также хороший
- если зная ответ для $[l, r]$ можно быстро считать ответ для $[l-1, r]$ и $[l, r + 1]$
]

== Задача
#text(size: 14pt)[
Автобус представляет собой ряд из n мест, пронумерованных от $1$ до $n$. Пассажиры садятся в автобус по следующим правилам:
- Если в автобусе нет занятых мест, пассажир может сесть на любое свободное место;
- Иначе пассажиру следует сесть на любое свободное место, рядом с которым есть занятое место. Другими словами, пассажир должен садиться на место с индексом $i(1≤i≤n)$, только если существует хотя бы одно из мест с индексами $i−1$ или $i+1$, и при этом хотя бы одно из этих мест занято. 

У вас есть список длины $n$ того, как рассаживались пассажиры. Определите, правильно ли они расселись.
]

== Префиксные суммы

#text(size: 14pt)[
#emph(text()[Дан массив целых чисел $a$, и приходят запросы вида «найти сумму на отрезке с позиции $l$ до позиции $r$».])

- Можно отвечать в лоб, но это долго

Заведем массив, который назовем массивом префиксных сумм(далее $p$) и определим его так:
- $p_0 = 0$
- $p_1 = a_0$
- $p_2 = a_0 + a_1$
- $dots$
- $p_k = Sigma_(i = 0)^(k - 1) a_i$

Посчитать его можно за $O(n)$
]

==
#text(size: 14pt)[
Теперь рассмотрим отрезок  $[l, r]$:
- Сумму на отрезке $[0, r]$ мы знаем(она равна $p_(r+1)$)
- Сумму на отрезке $[0, l - 1]$ мы знаем(она равна $p_l$)
- Сумма на отрезке $[l, r]$ это $Sigma [0, r] - Sigma[0, l - 1]$

Поскольку все эти значения у нас уже посчитаны, мы можем ответить на любой запрос за O(1).
]
== Задача

#text(size: 14pt)[
Дан массив целых чисел $a$, и приходят запросы вида «найти xor чисел на отрезке с позиции $l$ до позиции $r$».

]

