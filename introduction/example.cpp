#include<bits/stdc++.h>

using namespace std;

void scanline() {
    // Условие: Дан набор из n отрезков. Нужно найти какую-нибудь точку, которую покрывает наибольшее кол-во отрезков
    int n; cin >> n;
    vector<pair<int, int>> line; // Набор интересных точек
                                 // то есть тех, в которых отрезок открывается/закрывается
    for (int i = 0; i < n; i++) {
        int l, r; cin >> l >> r; // левая и правая граница отрезка
        line.push_back({l, 1}); // отрезок открывается
        line.push_back({r + 1, -1}); // отрезок закрывается в точке r+1(в точке r он ещё открыт, отрезок ведь) 
    }

    sort(line.begin(), line.end()); // sort() когда видит пару автоматически сравнивает элементы 
                                    // сначала по первому элементу, потом по второму и т.д.
                                    // Получается что здесь в первую очередь массив будет отсортирован по координате точки

    int cnt = 0; // количество открытых отрезков
    int ans_cnt = -1, ans = -1; // максимум, который мы встретили и где этот максимум встретили

    for (auto [point, type] : line) { // Проходимся по нашим интересным точкам в порядке возрастания их координат
        cnt += type; // Если отрезок закрывается, то -1 открытый отрезок; иначе +1
        if (cnt > ans_cnt) { // из-за того, что -1 < 1 сначала обработаются закрытия отрезков, из-за чего не будет 
                             // "ложных" максимумов
            ans_cnt = cnt;
            ans = point;
        }
    }

    cout << ans << "\n";
}

void two_pointers() {
    // Условие: дан массив положительных чисел a длины n, число k. Нужно найти максимальный по длине отрезок, такой,
    // что сумма элементов на нем равна k.
    int n, k; cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    int l = 0; // левый указатель(левая граница отрезка)
    long long sum = 0; // сумма на текущем отрезке
    int ans_len = -1; // длина самого длинного отрезка с суммой = k
    pair<int, int> ans = {-1, -1}; // текущий ответ
    for (int r = 0; r < n; r++) { // перебираем правую границу отрезка
        sum += a[r];
        while (l <= r && sum > k) { // двигаем левую границу пока на отрезке слишком большая сумма
            sum -= a[l];
            l++;
        }

        if (sum == k && (r - l + 1) > ans_len) { // обновляем ответ
            ans_len = (r - l + 1);
            ans = {l, r};
        }
    }
    cout << ans.first << ' ' << ans.second << "\n";
}

void pref_sum() {
    // Условие: Дан массив целых чисел a длиной n, приходит q запросов вида "найти сумму на отрезке от l до r"
    int n; cin >> n;
    vector<int> a(n), p(n + 1); // заводим массив префиксных сумм p; p[i] = a[0] + a[1] + ... a[i - 1]
    p[0] = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i];

        p[i + 1] = p[i] + a[i];
    }

    int q; cin >> q;
    for (int i = 0; i < q; i++) {
        int l, r; cin >> l >> r; 
        cout << p[r + 1] - p[l] << "\n"; 
    }
}

int main() {
    // scanline();
    // two_pointers();
    // pref_sum();
    return 0;
}
